#!/usr/bin/env bash
set -euo pipefail

PASS_PREFIX="${PASS_PREFIX:-upright}"
DEFAULT_NAME="${UPRIGHT_GPG_NAME:-Upright Deploy}"
DEFAULT_EMAIL="${UPRIGHT_GPG_EMAIL:-deploy@$(hostname -f 2>/dev/null || hostname)}"

need_cmd() {
  local name="$1"
  if command -v "${name}" >/dev/null 2>&1; then
    return 0
  fi
  echo "[ERROR] Missing required command after install attempt: ${name}" >&2
  echo "Install manually, then re-run this script." >&2
  exit 1
}

install_prereqs() {
  if command -v apt-get >/dev/null 2>&1; then
    echo "[INFO] Installing prerequisites via apt-get: gnupg2 pass pinentry-curses"
    sudo apt-get update -y
    sudo apt-get install -y gnupg2 pass pinentry-curses
    return 0
  fi
  if command -v dnf >/dev/null 2>&1; then
    echo "[INFO] Installing prerequisites via dnf: gnupg2 pass pinentry"
    sudo dnf install -y gnupg2 pass pinentry
    return 0
  fi
  if command -v yum >/dev/null 2>&1; then
    echo "[INFO] Installing prerequisites via yum: gnupg2 pass pinentry"
    sudo yum install -y gnupg2 pass pinentry
    return 0
  fi
  if command -v pacman >/dev/null 2>&1; then
    echo "[INFO] Installing prerequisites via pacman: gnupg pass pinentry"
    sudo pacman -Sy --noconfirm gnupg pass pinentry
    return 0
  fi
  echo "[ERROR] Unsupported package manager for automatic install." >&2
  return 1
}

AUTO_INSTALL_ATTEMPTED=0
ensure_cmd() {
  local name="$1"
  if command -v "${name}" >/dev/null 2>&1; then
    return 0
  fi
  echo "[WARN] Missing required command: ${name}"
  if [[ "${AUTO_INSTALL_ATTEMPTED}" != "1" ]]; then
    AUTO_INSTALL_ATTEMPTED=1
    install_prereqs || true
  fi
  need_cmd "${name}"
}

ensure_cmd gpg
ensure_cmd pass
if [[ -t 0 ]]; then
  export GPG_TTY="$(tty)"
fi

ensure_gnupg_homedir() {
  local gnupg_dir
  gnupg_dir="${HOME}/.gnupg"
  mkdir -p "${gnupg_dir}"
  chmod 700 "${gnupg_dir}" || true
  if compgen -G "${gnupg_dir}/*" >/dev/null 2>&1; then
    find "${gnupg_dir}" -type f -exec chmod 600 {} + >/dev/null 2>&1 || true
  fi
}

configure_gpg_agent() {
  local pinentry_bin agent_cfg
  pinentry_bin="$(command -v pinentry-curses || command -v pinentry || true)"
  agent_cfg="${HOME}/.gnupg/gpg-agent.conf"
  {
    echo "allow-loopback-pinentry"
    if [[ -n "${pinentry_bin}" ]]; then
      echo "pinentry-program ${pinentry_bin}"
    fi
  } > "${agent_cfg}"
  chmod 600 "${agent_cfg}" || true
  gpgconf --kill gpg-agent >/dev/null 2>&1 || true
  gpgconf --launch gpg-agent >/dev/null 2>&1 || true
}

ensure_gnupg_homedir
configure_gpg_agent

echo "Upright pass bootstrap (prefix: ${PASS_PREFIX})"

list_secret_keys() {
  gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '
    $1=="sec" {
      if (kid != "") {
        print kid "|" uid
      }
      kid=""
      uid=""
      want_fpr=1
      next
    }
    want_fpr && $1=="fpr" {
      kid=$10
      want_fpr=0
      next
    }
    $1=="uid" && kid!="" && uid=="" {
      uid=$10
      next
    }
    END {
      if (kid != "") {
        print kid "|" uid
      }
    }
  '
}

latest_secret_key_id() {
  gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '
    $1=="sec" { want_fpr=1; next }
    want_fpr && $1=="fpr" { id=$10; want_fpr=0; next }
    END { print id }
  '
}

create_new_key() {
  local gpg_name gpg_email key_id err_file loopback_pass
  read -r -p "GPG name [${DEFAULT_NAME}]: " gpg_name
  read -r -p "GPG email [${DEFAULT_EMAIL}]: " gpg_email
  gpg_name="${gpg_name:-${DEFAULT_NAME}}"
  gpg_email="${gpg_email:-${DEFAULT_EMAIL}}"
  echo "Generating key for ${gpg_name} <${gpg_email}>" >&2
  echo "You may be prompted for a passphrase in pinentry." >&2
  err_file="$(mktemp "${TMPDIR:-/tmp}/upright-gpg-keygen.XXXXXX")"
  if ! gpg --quick-generate-key "${gpg_name} <${gpg_email}>" default default 0 >/dev/null 2>"${err_file}"; then
    if grep -Eq 'agent_genkey failed: Permission denied|No pinentry|Inappropriate ioctl for device|cannot open /dev/tty' "${err_file}"; then
      echo "[WARN] Interactive key generation failed; retrying via loopback pinentry."
      read -r -s -p "Enter GPG passphrase for new key (leave blank for no passphrase): " loopback_pass
      echo
      if [[ -z "${loopback_pass}" ]]; then
        gpg --batch --pinentry-mode loopback --passphrase '' \
          --quick-generate-key "${gpg_name} <${gpg_email}>" default default 0 >/dev/null 2>>"${err_file}" || {
          cat "${err_file}" >&2
          rm -f "${err_file}"
          echo "Key generation failed." >&2
          exit 1
        }
      else
        printf '%s\n' "${loopback_pass}" | \
          gpg --batch --pinentry-mode loopback --passphrase-fd 0 \
            --quick-generate-key "${gpg_name} <${gpg_email}>" default default 0 >/dev/null 2>>"${err_file}" || {
            cat "${err_file}" >&2
            rm -f "${err_file}"
            echo "Key generation failed." >&2
            exit 1
          }
      fi
    else
      cat "${err_file}" >&2
      rm -f "${err_file}"
      echo "Key generation failed." >&2
      exit 1
    fi
  fi
  rm -f "${err_file}"
  key_id="$(latest_secret_key_id)"
  if [[ -z "${key_id}" ]]; then
    echo "[ERROR] Could not resolve newly created GPG key id." >&2
    exit 1
  fi
  printf '%s' "${key_id}"
}

choose_existing_key() {
  local rows key_count line key_id key_uid idx choice selected
  local -a key_ids
  local -a key_uids
  rows="$(list_secret_keys || true)"
  key_count=0
  while IFS= read -r line; do
    [[ -z "${line}" ]] && continue
    key_id="${line%%|*}"
    key_uid="${line#*|}"
    [[ -z "${key_id}" ]] && continue
    [[ "${key_uid}" == "${line}" || -z "${key_uid}" ]] && key_uid="(no uid)"
    key_ids+=("${key_id}")
    key_uids+=("${key_uid}")
    key_count=$((key_count + 1))
  done <<< "${rows}"

  if [[ "${key_count}" -eq 0 ]]; then
    echo "[ERROR] No existing secret keys found." >&2
    return 1
  fi

  echo "Available existing secret keys:" >&2
  idx=1
  while [[ "${idx}" -le "${key_count}" ]]; do
    echo "  ${idx}) ${key_ids[$((idx - 1))]}  ${key_uids[$((idx - 1))]}" >&2
    idx=$((idx + 1))
  done

  if [[ "${key_count}" -eq 1 ]]; then
    selected=1
  else
    while true; do
      read -r -p "Select key [1-${key_count}] [1]: " choice
      choice="${choice:-1}"
      if [[ "${choice}" =~ ^[0-9]+$ ]] && [[ "${choice}" -ge 1 ]] && [[ "${choice}" -le "${key_count}" ]]; then
        selected="${choice}"
        break
      fi
      echo "[WARN] Invalid selection: ${choice}" >&2
    done
  fi
  printf '%s' "${key_ids[$((selected - 1))]}"
}

verify_key_unlock() {
  local key_id="$1"
  local probe_file sig_file
  probe_file="$(mktemp "${TMPDIR:-/tmp}/upright-gpg-probe.XXXXXX")"
  sig_file="${probe_file}.asc"
  printf 'upright gpg unlock probe\n' > "${probe_file}"
  echo "Validating key access for ${key_id}. Enter passphrase when prompted."
  if gpg --yes --armor --local-user "${key_id}" --detach-sign --output "${sig_file}" "${probe_file}" >/dev/null 2>&1; then
    rm -f "${probe_file}" "${sig_file}"
    return 0
  fi
  rm -f "${probe_file}" "${sig_file}"
  return 1
}

KEY_ID=""
KEY_SOURCE=""
if gpg --list-secret-keys --with-colons | grep -q '^sec:'; then
  echo "Secret GPG key(s) found." >&2
  while true; do
    echo "Key setup mode:" >&2
    echo "  1) Use existing secret key" >&2
    echo "  2) Create a new secret key" >&2
    read -r -p "Choice [1]: " key_mode
    key_mode="${key_mode:-1}"
    if [[ "${key_mode}" == "1" ]]; then
      KEY_ID="$(choose_existing_key || true)"
      [[ -n "${KEY_ID}" ]] || continue
      KEY_SOURCE="existing"
      break
    fi
    if [[ "${key_mode}" == "2" ]]; then
      KEY_ID="$(create_new_key)"
      KEY_SOURCE="new"
      break
    fi
    echo "[WARN] Invalid key mode: ${key_mode}" >&2
  done
else
  echo "No secret GPG key found; creating a new key." >&2
  KEY_ID="$(create_new_key)"
  KEY_SOURCE="new"
fi

if [[ "${KEY_SOURCE}" == "existing" ]]; then
  while true; do
    if verify_key_unlock "${KEY_ID}"; then
      break
    fi
    read -r -p "Could not unlock key ${KEY_ID}. Retry? [Y/n]: " retry_unlock
    retry_unlock="${retry_unlock:-Y}"
    if [[ ! "${retry_unlock}" =~ ^[Yy]$ ]]; then
      echo "Aborting: unable to unlock selected key ${KEY_ID}." >&2
      exit 1
    fi
  done
fi

pass init "${KEY_ID}" >/dev/null 2>&1 || true
echo "Using GPG key id: ${KEY_ID}"

store_secret() {
  local key="$1"
  local env_name="$2"
  local prompt="$3"
  local hidden="${4:-yes}"
  local entry="${PASS_PREFIX}/${key}"
  local value="${!env_name:-}"
  if pass show "${entry}" >/dev/null 2>&1; then
    read -r -p "${entry} exists. Overwrite? [y/N]: " overwrite
    if [[ ! "${overwrite}" =~ ^[Yy]$ ]]; then
      echo "Skipping ${entry}"
      return 0
    fi
  fi
  if [[ -z "${value}" ]]; then
    if [[ "${hidden}" == "yes" ]]; then
      read -r -s -p "${prompt}: " value
      echo
    else
      read -r -p "${prompt}: " value
    fi
  fi
  if [[ -z "${value}" ]]; then
    echo "[ERROR] ${prompt} is required." >&2
    exit 1
  fi
  printf '%s\n' "${value}" | pass insert -m -f "${entry}" >/dev/null
  echo "Saved ${entry}"
}

store_secret "kamal/registry_password" "KAMAL_REGISTRY_PASSWORD" "Kamal registry password" "yes"
store_secret "admin_password" "ADMIN_PASSWORD" "Admin password" "yes"

echo
echo "Secrets stored in pass."
echo "Next:"
echo "  eval \"\$(~/bin/load-secrets)\""
echo "  cd ~/upright"
echo "  bin/kamal setup"
echo "  bin/kamal deploy"
