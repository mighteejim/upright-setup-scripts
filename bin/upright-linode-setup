#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
STATE_PATH="infra/state.json"
STACKSCRIPT_PATH="scripts/stackscript/upright-bootstrap.sh"

DRY_RUN=false
RESUME=false
DESTROY=false
NON_INTERACTIVE=false
AUTO_APPROVE=false

LINODE_PAT=""
ROOT_DOMAIN=""
UPRIGHT_SUFFIX=""
PLAN_MODE=""
INSTANCE_TYPE="g6-standard-2"
IMAGE="linode/ubuntu22.04"
DEPLOY_USER="jackley"
SSH_PORT="2222"
DNS_MODE=""
REGION_MODE=""
REGISTRY_SERVER="ghcr.io"
REGISTRY_USERNAME="mighteejim"
IMAGE_NAME="ghcr.io/mighteejim/upright"
SSH_PUBKEY_PATH=""
SSH_PUBKEY_VALUE=""
SSH_KEY_SOURCE=""
SSH_KEY_IDS=""
STACKSCRIPT_LABEL="upright-bootstrap"
STACKSCRIPT_ID=""
CLOUDFLARE_API_TOKEN=""
CLOUDFLARE_ZONE_ID=""
CURRENT_PHASE=""
RUN_DEPLOY=""
MANUAL_DNS_CONFIRMED=false
CONFIRM_DESTROY_FLAG=false
DELETE_STACKSCRIPT=false
OUTPUT_JSON=""

APP_REGION=""
ORD_REGION=""
IAD_REGION=""
SEA_REGION=""
APP_REGION_LABEL=""
ORD_REGION_LABEL=""
IAD_REGION_LABEL=""
SEA_REGION_LABEL=""
PLAN_TYPES_JSON=""
PROVISION_MODE="classic"
ROOT_DOMAIN_SELECTED_FROM_LINODE=false

if [[ -t 1 ]]; then
  C_RESET=$'\033[0m'
  C_BOLD=$'\033[1m'
  C_BLUE=$'\033[34m'
  C_CYAN=$'\033[36m'
  C_GREEN=$'\033[32m'
  C_YELLOW=$'\033[33m'
  C_RED=$'\033[31m'
  C_DIM=$'\033[2m'
else
  C_RESET=""
  C_BOLD=""
  C_BLUE=""
  C_CYAN=""
  C_GREEN=""
  C_YELLOW=""
  C_RED=""
  C_DIM=""
fi

banner() {
  cat <<EOF
${C_BLUE}${C_BOLD}
            .-""""-.
         .-'  .--.  '-.
       .'   /  _  \    '.
      /    |  (_)  |     \\
     ;      \\     /       ;
     |  .-._ '---' _.-.   |
     ; /    '-._.-'    \\  ;
      \\      /  |  \\      /
       '.   /   |   \\   .'
         '-._   |   _.-'
              '---'
${C_RESET}
${C_CYAN}${C_BOLD}  Upright Linode Setup Wizard${C_RESET}
${C_DIM}  Multi-site bootstrap: app + 3 monitors${C_RESET}
EOF
}

log() { printf '%b[%s]%b %s\n' "$C_DIM" "$1" "$C_RESET" "$2"; }
info() { printf '%b[INFO]%b %s\n' "$C_GREEN" "$C_RESET" "$1"; }
warn() { printf '%b[WARN]%b %s\n' "$C_YELLOW" "$C_RESET" "$1"; }
err() { printf '%b[ERROR]%b %s\n' "$C_RED" "$C_RESET" "$1" >&2; }

die() { err "$1"; emit_agent_output "error" "$1"; exit 1; }

spinner_sleep() {
  local seconds="$1"
  local message="$2"
  local frames='|/-\'
  local i=0

  if [[ ! -t 1 ]]; then
    sleep "$seconds"
    return
  fi

  local ticks=$((seconds * 10))
  while [[ "$i" -lt "$ticks" ]]; do
    local idx=$((i % 4))
    printf '\r%b%s %s%b' "$C_DIM" "$message" "${frames:$idx:1}" "$C_RESET"
    sleep 0.1
    i=$((i + 1))
  done
  printf '\r\033[K'
}

run_capture_with_spinner() {
  local __result_var="$1"
  shift
  local message="$1"
  shift

  local out_file err_file pid rc
  out_file="$(mktemp)"
  err_file="$(mktemp)"

  ("$@" >"$out_file" 2>"$err_file") &
  pid=$!

  if [[ -t 1 ]]; then
    local frames='|/-\'
    local i=0
    while kill -0 "$pid" 2>/dev/null; do
      local idx=$((i % 4))
      printf '\r%b%s %s%b' "$C_DIM" "$message" "${frames:$idx:1}" "$C_RESET"
      sleep 0.1
      i=$((i + 1))
    done
    printf '\r\033[K'
  fi

  wait "$pid"
  rc=$?

  if [[ -s "$err_file" ]]; then
    cat "$err_file" >&2
  fi

  if [[ "$rc" -ne 0 ]]; then
    rm -f "$out_file" "$err_file"
    return "$rc"
  fi

  local captured
  captured="$(cat "$out_file")"
  printf -v "$__result_var" '%s' "$captured"
  rm -f "$out_file" "$err_file"
}

usage() {
  cat <<USAGE
Usage: ${SCRIPT_NAME} [--dry-run] [--resume] [--destroy] [--non-interactive] [options]

Guided setup for Upright on Linode (local-run workflow).

Options:
  --dry-run   Show planned actions, do not mutate infrastructure
  --resume    Resume from ${STATE_PATH}
  --destroy   Tear down resources referenced in ${STATE_PATH}
  --non-interactive   Do not prompt; require args/defaults
  --yes       Auto-approve plan confirmation
  --output-json PATH  Write machine-readable run output JSON

Common config flags:
  --linode-pat TOKEN
  --root-domain DOMAIN
  --upright-suffix SUFFIX
  --plan-mode recommended|manual
  --instance-type PLAN_ID
  --region-mode recommended|manual
  --app-region REGION --ord-region REGION --iad-region REGION --sea-region REGION
  --dns-mode linode-dns|cloudflare-dns|manual
  --ssh-key-source linode-all|linode-ids|local-path
  --ssh-key-ids "123,456"
  --ssh-pubkey-path PATH
  --provision-mode classic
  --image IMAGE --deploy-user USER --ssh-port PORT
  --registry-server HOST --registry-username USER --image-name IMAGE
  --cloudflare-token TOKEN
  --run-deploy / --skip-deploy
  --manual-dns-confirmed
  --confirm-destroy
  --delete-stackscript
  -h, --help  Show this help
USAGE
}

ensure_repo_root() {
  [[ -f "config/deploy.yml" ]] || die "Run from repo root (missing config/deploy.yml)."
  [[ -f "$STACKSCRIPT_PATH" ]] || die "Missing $STACKSCRIPT_PATH"
}

install_linode_cli() {
  if command -v linode-cli >/dev/null 2>&1; then
    return
  fi

  warn "linode-cli not found; attempting install"

  if command -v brew >/dev/null 2>&1; then
    brew install linode-cli
    return
  fi

  if command -v apt-get >/dev/null 2>&1; then
    sudo apt-get update
    sudo apt-get install -y linode-cli
    return
  fi

  if command -v pipx >/dev/null 2>&1; then
    pipx install linode-cli
    return
  fi

  if command -v pip3 >/dev/null 2>&1; then
    pip3 install --user linode-cli
    return
  fi

  die "Could not install linode-cli automatically. Install it and rerun."
}

check_dependency() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || die "Missing required command: $cmd"
}

preflight() {
  ensure_repo_root
  install_linode_cli
  check_dependency linode-cli
  check_dependency jq
  check_dependency ssh
  check_dependency dig
  check_dependency docker
  check_dependency openssl
  check_dependency curl
  check_dependency bin/kamal
  check_dependency bin/load-secrets
}

linode_json() {
  if [[ -n "$LINODE_PAT" ]]; then
    LINODE_CLI_TOKEN="$LINODE_PAT" linode-cli "$@" --json
  else
    linode-cli "$@" --json
  fi
}

linode_cmd() {
  if [[ -n "$LINODE_PAT" ]]; then
    LINODE_CLI_TOKEN="$LINODE_PAT" linode-cli "$@"
  else
    linode-cli "$@"
  fi
}

prompt_linode_pat() {
  if $NON_INTERACTIVE; then
    die "--non-interactive: missing Linode auth. Set --linode-pat or pre-configure linode-cli auth."
  fi
  cat <<'TOKENINFO'
Linode API token required.
Create one at: https://cloud.linode.com/profile/tokens
Recommended scope: Read/Write for Linodes, StackScripts, Domains.
TOKENINFO

  read -r -s -p "Paste Linode PAT: " LINODE_PAT
  echo
  [[ -n "$LINODE_PAT" ]] || die "Linode PAT is required"
}

validate_linode_pat() {
  info "Validating Linode PAT"
  if ! LINODE_CLI_TOKEN="$LINODE_PAT" linode-cli account view --json >/dev/null 2>&1; then
    die "Linode PAT validation failed"
  fi
}

ensure_linode_auth() {
  if linode-cli account view --json >/dev/null 2>&1; then
    info "Using existing linode-cli authentication"
    return
  fi

  if [[ -n "$LINODE_PAT" ]]; then
    validate_linode_pat
    return
  fi

  prompt_linode_pat
  validate_linode_pat
}

load_ssh_pubkey() {
  local linode_keys_json linode_key_count
  linode_keys_json="$(linode_json sshkeys list)"
  linode_key_count="$(echo "$linode_keys_json" | jq 'length')"

  if [[ -z "$SSH_KEY_SOURCE" ]]; then
    if [[ -n "$SSH_KEY_IDS" ]]; then
      SSH_KEY_SOURCE="linode-ids"
    elif [[ -n "$SSH_PUBKEY_PATH" ]]; then
      SSH_KEY_SOURCE="local-path"
    elif [[ "$linode_key_count" -gt 0 ]]; then
      SSH_KEY_SOURCE="linode-all"
    else
      SSH_KEY_SOURCE="local-path"
    fi
  fi

  case "$SSH_KEY_SOURCE" in
    linode-all)
      local selected_keys
      selected_keys="$(echo "$linode_keys_json" | jq -r '.[].ssh_key' | awk '!seen[$0]++')"
      [[ -n "$selected_keys" ]] || die "No Linode SSH keys found to use from account"
      SSH_PUBKEY_PATH="linode:sshkey:all"
      SSH_PUBKEY_VALUE="$selected_keys"
      info "Using all Linode SSH keys (${linode_key_count})"
      return
      ;;
    linode-ids)
      [[ -n "$SSH_KEY_IDS" ]] || die "--ssh-key-source linode-ids requires --ssh-key-ids"
      local ids_csv selected_keys selected_labels missing ids_list
      ids_csv="$(echo "$SSH_KEY_IDS" | sed 's/,/ /g')"
      selected_keys=""
      selected_labels=""
      missing=""
      ids_list=""
      for id in $ids_csv; do
        local key label
        key="$(echo "$linode_keys_json" | jq -r --arg id "$id" '.[] | select((.id|tostring) == $id) | .ssh_key // empty')"
        label="$(echo "$linode_keys_json" | jq -r --arg id "$id" '.[] | select((.id|tostring) == $id) | .label // empty')"
        if [[ -z "$key" ]]; then
          missing="${missing}${id} "
          continue
        fi
        selected_keys="${selected_keys}${key}"$'\n'
        selected_labels="${selected_labels}${label},"
        ids_list="${ids_list}${id},"
      done
      [[ -z "$missing" ]] || die "Invalid Linode SSH key id(s): ${missing}"
      selected_keys="$(printf '%s' "$selected_keys" | awk 'NF && !seen[$0]++')"
      selected_labels="${selected_labels%,}"
      ids_list="${ids_list%,}"
      [[ -n "$selected_keys" ]] || die "No valid Linode SSH keys selected"
      SSH_PUBKEY_PATH="linode:sshkey:${ids_list}:${selected_labels}"
      SSH_PUBKEY_VALUE="$selected_keys"
      info "Using Linode SSH key id(s): ${ids_list}"
      return
      ;;
    local-path) ;;
    *) die "Invalid --ssh-key-source: ${SSH_KEY_SOURCE}" ;;
  esac

  if [[ "$linode_key_count" -gt 0 ]] && ! $NON_INTERACTIVE; then
    echo
    echo "Linode account SSH keys:"
    echo "$linode_keys_json" | jq -r '.[] | "  - \(.id) | \(.label)"'
    local selection normalized ids_csv selected_keys selected_labels missing ids_list
    while true; do
      read -r -p "Select your SSH key(s). Press A to select (A)all, or L to select a (L)ocal key, or enter a specific SSH key ID: " selection
      selection="${selection// /}"
      if [[ -z "$selection" ]]; then
        warn "Selection required. Use A, L, or a specific SSH key ID."
        continue
      fi

      normalized="$(echo "$selection" | tr '[:lower:]' '[:upper:]')"
      if [[ "$normalized" == "A" ]]; then
        selected_keys="$(echo "$linode_keys_json" | jq -r '.[].ssh_key' | awk '!seen[$0]++')"
        if [[ -n "$selected_keys" ]]; then
          SSH_PUBKEY_PATH="linode:sshkey:all"
          SSH_PUBKEY_VALUE="$selected_keys"
          info "Using all Linode SSH keys (${linode_key_count})"
          return
        fi
        warn "No SSH keys found to use from Linode account"
        continue
      fi
      if [[ "$normalized" == "L" ]]; then
        break
      fi

      ids_csv="$(echo "$selection" | sed 's/,/ /g')"
      selected_keys=""
      selected_labels=""
      missing=""
      ids_list=""
      for id in $ids_csv; do
        local key label
        key="$(echo "$linode_keys_json" | jq -r --arg id "$id" '.[] | select((.id|tostring) == $id) | .ssh_key // empty')"
        label="$(echo "$linode_keys_json" | jq -r --arg id "$id" '.[] | select((.id|tostring) == $id) | .label // empty')"
        if [[ -z "$key" ]]; then
          missing="${missing}${id} "
          continue
        fi
        selected_keys="${selected_keys}${key}"$'\n'
        selected_labels="${selected_labels}${label},"
        ids_list="${ids_list}${id},"
      done

      if [[ -n "$missing" ]]; then
        warn "Invalid Linode SSH key id(s): ${missing}"
        continue
      fi

      selected_keys="$(printf '%s' "$selected_keys" | awk 'NF && !seen[$0]++')"
      selected_labels="${selected_labels%,}"
      ids_list="${ids_list%,}"

      if [[ -n "$selected_keys" ]]; then
        SSH_PUBKEY_PATH="linode:sshkey:${ids_list}:${selected_labels}"
        SSH_PUBKEY_VALUE="$selected_keys"
        info "Using Linode SSH key id(s): ${ids_list}"
        return
      fi

      warn "No valid Linode SSH keys selected"
    done
  else
    [[ "$linode_key_count" -gt 0 ]] || warn "No Linode SSH keys found in account; falling back to local public key"
  fi

  local default_path="${HOME}/.ssh/id_ed25519.pub"
  [[ -f "$default_path" ]] || default_path="${HOME}/.ssh/id_rsa.pub"

  if [[ -z "$SSH_PUBKEY_PATH" ]]; then
    if $NON_INTERACTIVE; then
      SSH_PUBKEY_PATH="$default_path"
    else
      read -r -p "SSH public key path [${default_path}]: " SSH_PUBKEY_PATH
      SSH_PUBKEY_PATH="${SSH_PUBKEY_PATH:-$default_path}"
    fi
  fi

  [[ -f "$SSH_PUBKEY_PATH" ]] || die "SSH public key not found: ${SSH_PUBKEY_PATH}"
  SSH_PUBKEY_VALUE="$(cat "$SSH_PUBKEY_PATH")"
  [[ -n "$SSH_PUBKEY_VALUE" ]] || die "SSH public key file is empty"
}

prompt_inputs() {
  prompt_root_domain

  if [[ -z "$UPRIGHT_SUFFIX" ]]; then
    if $NON_INTERACTIVE; then
      UPRIGHT_SUFFIX="up.${ROOT_DOMAIN}"
    else
      read -r -p "Upright suffix [up.${ROOT_DOMAIN}]: " UPRIGHT_SUFFIX
      UPRIGHT_SUFFIX="${UPRIGHT_SUFFIX:-up.${ROOT_DOMAIN}}"
    fi
  fi

  choose_instance_type

  if [[ "$PROVISION_MODE" == "tui" ]]; then
    warn "Provisioning mode 'tui' is deprecated; using classic provisioning"
    PROVISION_MODE="classic"
  fi
  [[ "$PROVISION_MODE" == "classic" ]] || PROVISION_MODE="classic"

  if ! $NON_INTERACTIVE; then
    read -r -p "Image slug [${IMAGE}]: " _tmp
    IMAGE="${_tmp:-$IMAGE}"

    read -r -p "Deploy user [${DEPLOY_USER}]: " _tmp
    DEPLOY_USER="${_tmp:-$DEPLOY_USER}"

    read -r -p "SSH port [${SSH_PORT}]: " _tmp
    SSH_PORT="${_tmp:-$SSH_PORT}"

    read -r -p "Registry server [${REGISTRY_SERVER}]: " _tmp
    REGISTRY_SERVER="${_tmp:-$REGISTRY_SERVER}"

    read -r -p "Registry username [${REGISTRY_USERNAME}]: " _tmp
    REGISTRY_USERNAME="${_tmp:-$REGISTRY_USERNAME}"

    read -r -p "Image name [${IMAGE_NAME}]: " _tmp
    IMAGE_NAME="${_tmp:-$IMAGE_NAME}"
  fi

  select_dns_mode
  choose_regions
}

prompt_root_domain() {
  local domains_json domains_list selection normalized
  if [[ -n "$ROOT_DOMAIN" ]]; then
    domains_json="$(linode_json domains list)"
    domains_list="$(echo "$domains_json" | jq -r '.[].domain // empty')"
    if [[ -n "$domains_list" ]] && echo "$domains_list" | grep -Fxq "$ROOT_DOMAIN"; then
      ROOT_DOMAIN_SELECTED_FROM_LINODE=true
      info "Selected Linode domain: ${ROOT_DOMAIN}"
    else
      ROOT_DOMAIN_SELECTED_FROM_LINODE=false
    fi
    return
  fi

  if $NON_INTERACTIVE; then
    die "--non-interactive requires --root-domain"
  fi

  domains_json="$(linode_json domains list)"
  domains_list="$(echo "$domains_json" | jq -r '.[].domain // empty')"

  if [[ -n "$domains_list" ]]; then
    echo
    echo "Linode domains:"
    echo "$domains_list" | nl -w1 -s') '
    echo "Enter a number to select a Linode-managed domain, or type a custom domain."
  fi

  while true; do
    read -r -p "Root domain (e.g. ckley.net): " selection
    selection="${selection// /}"
    [[ -n "$selection" ]] || { warn "Root domain is required"; continue; }

    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ -n "$domains_list" ]]; then
      ROOT_DOMAIN="$(echo "$domains_list" | sed -n "${selection}p")"
      if [[ -n "$ROOT_DOMAIN" ]]; then
        ROOT_DOMAIN_SELECTED_FROM_LINODE=true
        info "Selected Linode domain: ${ROOT_DOMAIN}"
        return
      fi
      warn "Invalid domain selection: ${selection}"
      continue
    fi

    ROOT_DOMAIN="$selection"
    ROOT_DOMAIN_SELECTED_FROM_LINODE=false
    return
  done
}

fetch_allowed_instance_types() {
  linode_json linodes types | jq '
    map(
      select(
        (.id | test("^g6-(nanode|standard)-")) or
        (.id | test("^g6-dedicated-[0-9]+$")) or
        (.id | test("^g7-dedicated-")) or
        (.id | test("^g8-dedicated-"))
      )
    )
  '
}

plan_display_name() {
  local type_id="$1"
  local memory_mb="$2"
  local memory_gb="$((memory_mb / 1024))"

  if [[ "$type_id" =~ ^g6-(nanode|standard)- ]]; then
    printf 'Linode %s GB' "$memory_gb"
    return
  fi

  if [[ "$type_id" =~ ^g[678]-dedicated- ]]; then
    printf 'Dedicated %s GB' "$memory_gb"
    return
  fi

  printf '%s' "$type_id"
}

plan_price_monthly_for_id() {
  local type_id="$1"
  echo "$PLAN_TYPES_JSON" | jq -r --arg id "$type_id" '.[] | select(.id == $id) | .price.monthly // empty'
}

calc_monthly_total() {
  local per_node="$1"
  awk -v price="$per_node" 'BEGIN { printf "%.2f", price * 4 }'
}

plan_human_label_for_id() {
  local type_id="$1"
  local row memory_mb vcpus disk_mb monthly id display_name
  row="$(echo "$PLAN_TYPES_JSON" | jq -r --arg id "$type_id" '.[] | select(.id == $id) | [.id, (.memory|tostring), (.vcpus|tostring), (.disk|tostring), (.price.monthly|tostring)] | @tsv' | head -n1)"
  [[ -n "$row" ]] || { printf '%s' "$type_id"; return; }
  IFS=$'\t' read -r id memory_mb vcpus disk_mb monthly <<<"$row"
  display_name="$(plan_display_name "$id" "$memory_mb")"
  printf '%s (%s, %svCPU, %sGB RAM, %sGB disk, $%s/mo)' "$display_name" "$id" "$vcpus" "$((memory_mb / 1024))" "$((disk_mb / 1024))" "$monthly"
}

print_upright_requirements() {
  cat <<'REQS'

Upright system requirements:
  Resource   Minimum   Recommended
  CPU        2 vCPU    2 vCPU
  RAM        2 GB      4 GB
  Disk       25 GB     50 GB

REQS
}

print_instance_types_grouped() {
  local types_json="$1"
  echo
  echo "Available plans (GPU and other non-target plan families are excluded):"
  echo

  echo "Shared:"
  echo "$types_json" | jq -r '
    [ .[]
    | select(.id | test("^g6-(nanode|standard)-"))
    ] | sort_by(.memory, .vcpus, .disk, .price.monthly)[] |
    "  - Linode \((.memory/1024|floor)) GB (\(.id)) | \(.vcpus) vCPU | \((.memory/1024|floor)) GB RAM | \((.disk/1024|floor)) GB disk | $\(.price.monthly)/mo"
  '
  echo

  echo "g6-dedicated:"
  echo "$types_json" | jq -r '
    [ .[]
    | select(.id | test("^g6-dedicated-[0-9]+$"))
    ] | sort_by(.memory, .vcpus, .disk, .price.monthly)[] |
    "  - Dedicated \((.memory/1024|floor)) GB (\(.id)) | \(.vcpus) vCPU | \((.memory/1024|floor)) GB RAM | \((.disk/1024|floor)) GB disk | $\(.price.monthly)/mo"
  '
  echo

  echo "g7-dedicated:"
  echo "$types_json" | jq -r '
    [ .[]
    | select(.id | test("^g7-dedicated-"))
    ] | sort_by(.memory, .vcpus, .disk, .price.monthly)[] |
    "  - Dedicated \((.memory/1024|floor)) GB (\(.id)) | \(.vcpus) vCPU | \((.memory/1024|floor)) GB RAM | \((.disk/1024|floor)) GB disk | $\(.price.monthly)/mo"
  '
  echo

  echo "g8-dedicated:"
  echo "$types_json" | jq -r '
    [ .[]
    | select(.id | test("^g8-dedicated-"))
    ] | sort_by(.memory, .vcpus, .disk, .price.monthly)[] |
    "  - Dedicated \((.memory/1024|floor)) GB (\(.id)) | \(.vcpus) vCPU | \((.memory/1024|floor)) GB RAM | \((.disk/1024|floor)) GB disk | $\(.price.monthly)/mo"
  '
}

choose_instance_type() {
  local types_json ids selected
  types_json="$(fetch_allowed_instance_types)"
  PLAN_TYPES_JSON="$types_json"
  ids="$(echo "$types_json" | jq -r '.[].id')"

  [[ -n "$ids" ]] || die "No allowed instance types returned from Linode API."
  print_upright_requirements

  local recommended_plan="g6-standard-2"
  local recommended_price
  recommended_price="$(plan_price_monthly_for_id "$recommended_plan")"

  if [[ -z "$PLAN_MODE" && $NON_INTERACTIVE == true ]]; then
    if [[ "$INSTANCE_TYPE" != "$recommended_plan" ]]; then
      PLAN_MODE="manual"
    else
      PLAN_MODE="recommended"
    fi
  fi

  if [[ "$PLAN_MODE" == "recommended" ]]; then
    if [[ -z "$recommended_price" ]]; then
      die "Recommended plan ${recommended_plan} not available; set --plan-mode manual --instance-type <id>"
    fi
    INSTANCE_TYPE="$recommended_plan"
    info "Using recommended plan: ${recommended_plan}"
    return
  fi

  if [[ "$PLAN_MODE" == "manual" ]]; then
    if echo "$ids" | grep -qx "$INSTANCE_TYPE"; then
      return
    fi
    if $NON_INTERACTIVE; then
      die "Invalid --instance-type: ${INSTANCE_TYPE}"
    fi
    warn "Manual plan '${INSTANCE_TYPE}' not valid; switching to interactive selection."
    print_instance_types_grouped "$types_json"
    while true; do
      read -r -p "Select plan id [${INSTANCE_TYPE}]: " selected
      selected="${selected:-$INSTANCE_TYPE}"
      if echo "$ids" | grep -qx "$selected"; then
        INSTANCE_TYPE="$selected"
        return
      fi
      warn "Invalid plan id: ${selected}"
    done
  fi

  if [[ -n "$PLAN_MODE" ]]; then
    die "Invalid --plan-mode: ${PLAN_MODE} (expected recommended|manual)"
  fi

  if [[ -z "$recommended_price" ]]; then
    warn "Recommended plan ${recommended_plan} not available; falling back to manual selection."
    print_instance_types_grouped "$types_json"
  else
    INSTANCE_TYPE="$recommended_plan"
    local recommended_total
    recommended_total="$(calc_monthly_total "$recommended_price")"
    echo "Plan selection:"
    echo "  1) Deploy recommended config (4 nodes, Shared 4 GB: ${recommended_plan}, approx \$${recommended_total}/mo)"
    echo "  2) Manual plan selection"

    while true; do
      read -r -p "Choice [1]: " selected
      case "${selected:-1}" in
        1)
          info "Using recommended plan: ${recommended_plan}"
          return
          ;;
        2)
          print_instance_types_grouped "$types_json"
          break
          ;;
        *)
          warn "Invalid choice: ${selected}"
          ;;
      esac
    done
  fi

  while true; do
    read -r -p "Select plan id [${INSTANCE_TYPE}]: " selected
    selected="${selected:-$INSTANCE_TYPE}"
    if echo "$ids" | grep -qx "$selected"; then
      INSTANCE_TYPE="$selected"
      return
    fi
    warn "Invalid plan id: ${selected}"
  done
}

select_dns_mode() {
  if [[ -n "$DNS_MODE" ]]; then
    case "$DNS_MODE" in
      linode-dns|cloudflare-dns|manual) ;;
      *) die "Invalid --dns-mode: ${DNS_MODE}" ;;
    esac
    return
  fi

  if [[ "$ROOT_DOMAIN_SELECTED_FROM_LINODE" == true ]]; then
    DNS_MODE="linode-dns"
    info "Auto-selected DNS mode: linode-dns (root domain selected from Linode domains)"
    return
  fi

  if $NON_INTERACTIVE; then
    DNS_MODE="manual"
    return
  fi

  cat <<'DNSMENU'
Select DNS mode:
  1) linode-dns
  2) cloudflare-dns
  3) manual
DNSMENU
  read -r -p "Choice [3]: " _choice
  case "${_choice:-3}" in
    1) DNS_MODE="linode-dns" ;;
    2) DNS_MODE="cloudflare-dns" ;;
    3) DNS_MODE="manual" ;;
    *) die "Invalid DNS mode choice" ;;
  esac
}

fetch_regions() {
  linode_json regions list
}

print_regions_grouped() {
  local regions_json="$1"
  local grouped
  grouped="$(echo "$regions_json" | jq '
    map(
      . + {
        geo:
          (if (.country | IN("us","ca","mx","br","co","cl")) then "Americas"
           elif (.country | IN("gb","de","fr","nl","se","es","it")) then "Europe"
           elif (.country | IN("in","jp","sg","au","nz","id","my")) then "APAC"
           elif (.country | IN("za")) then "Africa / MEA"
           else "Other"
           end)
      }
    )
  ')"

  echo
  echo "Available regions (enter region id values):"
  for geo in "Americas" "Europe" "APAC" "Africa / MEA" "Other"; do
    local lines
    lines="$(echo "$grouped" | jq -r --arg geo "$geo" '.[] | select(.geo == $geo) | "  - \(.id) | \(.label) | country=\(.country) | site_type=\(.site_type)"')"
    if [[ -n "$lines" ]]; then
      echo
      echo "${geo}:"
      echo "$lines"
    fi
  done
}

choose_region_for_role() {
  local role="$1"
  local regions_json="$2"
  local default_region="${3:-}"
  local ids
  local env_key selected
  ids="$(echo "$regions_json" | jq -r '.[].id')"
  env_key="$(echo "${role}" | tr '[:lower:]' '[:upper:]')_REGION"
  selected="${!env_key:-}"

  if [[ -n "$selected" ]]; then
    if echo "$ids" | grep -qx "$selected"; then
      printf '%s' "$selected"
      return
    fi
    die "Invalid region id for ${role}: ${selected}"
  fi

  while true; do
    if [[ -n "$default_region" ]]; then
      read -r -p "Select region id for ${role} [${default_region}]: " selected
      selected="${selected:-$default_region}"
    else
      read -r -p "Select region id for ${role}: " selected
    fi
    if echo "$ids" | grep -qx "$selected"; then
      printf '%s' "$selected"
      return
    fi
    warn "Invalid region id: ${selected}"
  done
}

choose_regions() {
  info "Fetching regions from Linode"
  local regions_json
  regions_json="$(fetch_regions)"
  if ! $NON_INTERACTIVE; then
    print_regions_grouped "$regions_json"
  fi

  local default_app_region="us-iad"
  local default_ord_region="us-ord"
  local default_iad_region="us-iad"
  local default_sea_region="us-sea"

  if [[ -z "$REGION_MODE" ]]; then
    if [[ -n "$APP_REGION$ORD_REGION$IAD_REGION$SEA_REGION" ]]; then
      REGION_MODE="manual"
    elif $NON_INTERACTIVE; then
      REGION_MODE="recommended"
    else
      REGION_MODE="recommended"
    fi
  fi

  case "$REGION_MODE" in
    recommended)
      APP_REGION="$default_app_region"
      ORD_REGION="$default_ord_region"
      IAD_REGION="$default_iad_region"
      SEA_REGION="$default_sea_region"
      ;;
    manual)
      if $NON_INTERACTIVE && [[ -z "$APP_REGION" || -z "$ORD_REGION" || -z "$IAD_REGION" || -z "$SEA_REGION" ]]; then
        die "--region-mode manual requires --app-region/--ord-region/--iad-region/--sea-region"
      fi
      ;;
    *)
      die "Invalid --region-mode: ${REGION_MODE} (expected recommended|manual)"
      ;;
  esac

  if ! $NON_INTERACTIVE; then
    echo
    echo "Recommended default topology:"
    echo "  app -> ${default_app_region} (Washington, DC)"
    echo "  ord -> ${default_ord_region} (Chicago, IL)"
    echo "  iad -> ${default_iad_region} (Washington, DC)"
    echo "  sea -> ${default_sea_region} (Seattle, WA)"
    echo "Press Enter to accept defaults."
  fi

  if [[ "$REGION_MODE" == "manual" ]]; then
    APP_REGION="$(choose_region_for_role app "$regions_json" "$default_app_region")"
    ORD_REGION="$(choose_region_for_role ord "$regions_json" "$default_ord_region")"
    IAD_REGION="$(choose_region_for_role iad "$regions_json" "$default_iad_region")"
    SEA_REGION="$(choose_region_for_role sea "$regions_json" "$default_sea_region")"
  fi
  APP_REGION_LABEL="$(echo "$regions_json" | jq -r --arg id "$APP_REGION" '.[] | select(.id == $id) | .label // $id')"
  ORD_REGION_LABEL="$(echo "$regions_json" | jq -r --arg id "$ORD_REGION" '.[] | select(.id == $id) | .label // $id')"
  IAD_REGION_LABEL="$(echo "$regions_json" | jq -r --arg id "$IAD_REGION" '.[] | select(.id == $id) | .label // $id')"
  SEA_REGION_LABEL="$(echo "$regions_json" | jq -r --arg id "$SEA_REGION" '.[] | select(.id == $id) | .label // $id')"
}

print_deployment_cost_summary() {
  local each_monthly total_monthly plan_label
  each_monthly="$(plan_price_monthly_for_id "$INSTANCE_TYPE")"
  [[ -n "$each_monthly" ]] || each_monthly="0"
  total_monthly="$(calc_monthly_total "$each_monthly")"
  plan_label="$(plan_human_label_for_id "$INSTANCE_TYPE")"

  echo
  echo "Deployment summary (approx monthly cost):"
  printf '  %-6s %-22s %-24s %-44s %9s\n' "Node" "Host" "Region" "Plan" "Cost/mo"
  printf '  %-6s %-22s %-24s %-44s %9s\n' "------" "----------------------" "------------------------" "--------------------------------------------" "---------"
  printf '  %-6s %-22s %-24s %-44s $%8s\n' "app" "app.${UPRIGHT_SUFFIX}" "${APP_REGION} (${APP_REGION_LABEL})" "$plan_label" "$each_monthly"
  printf '  %-6s %-22s %-24s %-44s $%8s\n' "ord" "ord.${UPRIGHT_SUFFIX}" "${ORD_REGION} (${ORD_REGION_LABEL})" "$plan_label" "$each_monthly"
  printf '  %-6s %-22s %-24s %-44s $%8s\n' "iad" "iad.${UPRIGHT_SUFFIX}" "${IAD_REGION} (${IAD_REGION_LABEL})" "$plan_label" "$each_monthly"
  printf '  %-6s %-22s %-24s %-44s $%8s\n' "sea" "sea.${UPRIGHT_SUFFIX}" "${SEA_REGION} (${SEA_REGION_LABEL})" "$plan_label" "$each_monthly"
  printf '  %-6s %-22s %-24s %-44s %9s\n' "" "" "" "Total (4 nodes)" "\$${total_monthly}/mo"
}

confirm_plan() {
  print_deployment_cost_summary

  cat <<SUMMARY

Plan summary:
  Root domain:        ${ROOT_DOMAIN}
  Upright suffix:     ${UPRIGHT_SUFFIX}
  DNS mode:           ${DNS_MODE}
  Registry server:    ${REGISTRY_SERVER}
  Registry username:  ${REGISTRY_USERNAME}
  Image name:         ${IMAGE_NAME}
  Instance type:      ${INSTANCE_TYPE}
  Provision mode:     ${PROVISION_MODE}
  Image:              ${IMAGE}
  Deploy user:        ${DEPLOY_USER}
  SSH port:           ${SSH_PORT}
  StackScript label:  ${STACKSCRIPT_LABEL}
  Regions:
    app=${APP_REGION} (${APP_REGION_LABEL})
    ord=${ORD_REGION} (${ORD_REGION_LABEL})
    iad=${IAD_REGION} (${IAD_REGION_LABEL})
    sea=${SEA_REGION} (${SEA_REGION_LABEL})
  SSH public key:     ${SSH_PUBKEY_PATH}
SUMMARY

  if $AUTO_APPROVE || $NON_INTERACTIVE; then
    info "Proceeding without interactive confirmation"
    return
  fi

  read -r -p "Proceed? [y/N]: " yn
  [[ "${yn}" =~ ^[Yy]$ ]] || die "Cancelled"
}

init_state() {
  mkdir -p "$(dirname "$STATE_PATH")"

  jq -n \
    --arg generated_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    --arg phase "planning" \
    --arg root_domain "$ROOT_DOMAIN" \
    --arg upright_suffix "$UPRIGHT_SUFFIX" \
    --arg dns_mode "$DNS_MODE" \
    --arg registry_server "$REGISTRY_SERVER" \
    --arg registry_username "$REGISTRY_USERNAME" \
    --arg image_name "$IMAGE_NAME" \
    --arg instance_type "$INSTANCE_TYPE" \
    --arg provision_mode "$PROVISION_MODE" \
    --arg image "$IMAGE" \
    --arg deploy_user "$DEPLOY_USER" \
    --arg ssh_port "$SSH_PORT" \
    --arg stackscript_label "$STACKSCRIPT_LABEL" \
    --arg app_region "$APP_REGION" \
    --arg ord_region "$ORD_REGION" \
    --arg iad_region "$IAD_REGION" \
    --arg sea_region "$SEA_REGION" \
    '{
      generated_at: $generated_at,
      phase: $phase,
      stackscript: { label: $stackscript_label, id: null },
      dns: { mode: $dns_mode, status: "pending" },
      config: {
        root_domain: $root_domain,
        upright_suffix: $upright_suffix,
        dns_mode: $dns_mode,
        registry_server: $registry_server,
        registry_username: $registry_username,
        image_name: $image_name,
        instance_type: $instance_type,
        provision_mode: $provision_mode,
        image: $image,
        deploy_user: $deploy_user,
        ssh_port: $ssh_port
      },
      regions: { app: $app_region, ord: $ord_region, iad: $iad_region, sea: $sea_region },
      nodes: [
        { role: "app", code: "app", region: $app_region, fqdn: ("app." + $upright_suffix), linode_id: null, ipv4: null, status: "planned" },
        { role: "monitor", code: "ord", region: $ord_region, fqdn: ("ord." + $upright_suffix), linode_id: null, ipv4: null, status: "planned" },
        { role: "monitor", code: "iad", region: $iad_region, fqdn: ("iad." + $upright_suffix), linode_id: null, ipv4: null, status: "planned" },
        { role: "monitor", code: "sea", region: $sea_region, fqdn: ("sea." + $upright_suffix), linode_id: null, ipv4: null, status: "planned" }
      ]
    }' > "$STATE_PATH"

  info "Wrote planning state to ${STATE_PATH}"
}

load_state_context() {
  [[ -f "$STATE_PATH" ]] || die "No state file found at ${STATE_PATH}"

  CURRENT_PHASE="$(jq -r '.phase // "planning"' "$STATE_PATH")"
  ROOT_DOMAIN="$(jq -r '.config.root_domain' "$STATE_PATH")"
  UPRIGHT_SUFFIX="$(jq -r '.config.upright_suffix' "$STATE_PATH")"
  DNS_MODE="$(jq -r '.config.dns_mode // .dns.mode // "manual"' "$STATE_PATH")"
  REGISTRY_SERVER="$(jq -r '.config.registry_server // "ghcr.io"' "$STATE_PATH")"
  REGISTRY_USERNAME="$(jq -r '.config.registry_username // "mighteejim"' "$STATE_PATH")"
  IMAGE_NAME="$(jq -r '.config.image_name // "ghcr.io/mighteejim/upright"' "$STATE_PATH")"
  INSTANCE_TYPE="$(jq -r '.config.instance_type // "g6-standard-2"' "$STATE_PATH")"
  PROVISION_MODE="$(jq -r '.config.provision_mode // "classic"' "$STATE_PATH")"
  if [[ "$PROVISION_MODE" == "tui" ]]; then
    warn "State file provision_mode=tui is deprecated; using classic provisioning"
    PROVISION_MODE="classic"
  fi
  IMAGE="$(jq -r '.config.image // "linode/ubuntu22.04"' "$STATE_PATH")"
  DEPLOY_USER="$(jq -r '.config.deploy_user // "jackley"' "$STATE_PATH")"
  SSH_PORT="$(jq -r '.config.ssh_port // "2222"' "$STATE_PATH")"

  APP_REGION="$(jq -r '.regions.app // empty' "$STATE_PATH")"
  ORD_REGION="$(jq -r '.regions.ord // empty' "$STATE_PATH")"
  IAD_REGION="$(jq -r '.regions.iad // empty' "$STATE_PATH")"
  SEA_REGION="$(jq -r '.regions.sea // empty' "$STATE_PATH")"

  STACKSCRIPT_LABEL="$(jq -r '.stackscript.label // "upright-bootstrap"' "$STATE_PATH")"
  STACKSCRIPT_ID="$(jq -r '.stackscript.id // empty' "$STATE_PATH")"

  info "Loaded state phase=${CURRENT_PHASE}"
}

save_stackscript_state() {
  jq --arg id "$STACKSCRIPT_ID" '.stackscript.id = ($id | tonumber)' "$STATE_PATH" > "${STATE_PATH}.tmp"
  mv "${STATE_PATH}.tmp" "$STATE_PATH"
}

update_node_state() {
  local code="$1" linode_id="$2" ipv4="$3" status="$4"
  jq \
    --arg code "$code" \
    --arg id "$linode_id" \
    --arg ip "$ipv4" \
    --arg status "$status" \
    '(.nodes[] | select(.code == $code)).linode_id = (if ($id | test("^[0-9]+$")) then ($id | tonumber) else null end)
     | (.nodes[] | select(.code == $code)).ipv4 = $ip
     | (.nodes[] | select(.code == $code)).status = $status' \
    "$STATE_PATH" > "${STATE_PATH}.tmp"
  mv "${STATE_PATH}.tmp" "$STATE_PATH"
}

set_phase() {
  local phase="$1"
  jq --arg phase "$phase" '.phase = $phase' "$STATE_PATH" > "${STATE_PATH}.tmp"
  mv "${STATE_PATH}.tmp" "$STATE_PATH"
}

set_dns_status() {
  local status="$1"
  jq --arg status "$status" '.dns.status = $status' "$STATE_PATH" > "${STATE_PATH}.tmp"
  mv "${STATE_PATH}.tmp" "$STATE_PATH"
}

node_ipv4() {
  local code="$1"
  jq -r --arg code "$code" '.nodes[] | select(.code == $code) | .ipv4 // ""' "$STATE_PATH"
}

node_linode_id() {
  local code="$1"
  jq -r --arg code "$code" '.nodes[] | select(.code == $code) | .linode_id // ""' "$STATE_PATH"
}

record_name_for_code() {
  local code="$1" suffix_without_root
  if [[ "$UPRIGHT_SUFFIX" == "$ROOT_DOMAIN" ]]; then
    printf '%s' "$code"
    return
  fi

  suffix_without_root="${UPRIGHT_SUFFIX%.$ROOT_DOMAIN}"
  if [[ "$suffix_without_root" == "$UPRIGHT_SUFFIX" || -z "$suffix_without_root" ]]; then
    printf '%s' "$code"
  else
    printf '%s.%s' "$code" "$suffix_without_root"
  fi
}

fqdn_for_code() {
  local code="$1"
  printf '%s.%s' "$code" "$UPRIGHT_SUFFIX"
}

ensure_stackscript() {
  local script_content existing

  if $DRY_RUN; then
    info "DRY-RUN: would create/update private StackScript '${STACKSCRIPT_LABEL}'"
    STACKSCRIPT_ID=0
    return
  fi

  script_content="$(cat "$STACKSCRIPT_PATH")"
  existing="$(linode_json stackscripts list --mine true --label "$STACKSCRIPT_LABEL")"
  STACKSCRIPT_ID="$(echo "$existing" | jq -r '.[0].id // empty')"

  if [[ -n "$STACKSCRIPT_ID" ]]; then
    info "Updating existing StackScript id=${STACKSCRIPT_ID}"
    linode_cmd stackscripts update "$STACKSCRIPT_ID" \
      --label "$STACKSCRIPT_LABEL" \
      --images "$IMAGE" \
      --is_public false \
      --script "$script_content" \
      --rev_note "upright-bootstrap sync $(date -u +%Y-%m-%dT%H:%M:%SZ)" >/dev/null
  else
    info "Creating private StackScript '${STACKSCRIPT_LABEL}'"
    local created
    created="$(linode_cmd stackscripts create \
      --label "$STACKSCRIPT_LABEL" \
      --description "Bootstrap Ubuntu host for Upright deployment" \
      --images "$IMAGE" \
      --is_public false \
      --script "$script_content" --json)"
    STACKSCRIPT_ID="$(echo "$created" | jq -r '.[0].id // .id // empty')"
  fi

  [[ -n "$STACKSCRIPT_ID" ]] || die "Failed to resolve StackScript ID"
  info "Using StackScript id=${STACKSCRIPT_ID}"
}

wait_for_linode_running() {
  local linode_id="$1" node_code="$2" status ipv4 payload

  info "Waiting for Linode deploy to complete (${node_code}, id=${linode_id})"

  for _ in $(seq 1 40); do
    payload="$(linode_json linodes view "$linode_id")"
    status="$(echo "$payload" | jq -r '.[0].status // .status // ""')"
    ipv4="$(echo "$payload" | jq -r '(.[0].ipv4 // .ipv4 // [])[0] // ""')"
    if [[ "$status" == "running" && -n "$ipv4" ]]; then
      printf '%s|%s' "$status" "$ipv4"
      return
    fi
    spinner_sleep 10 "Waiting for Linode deploy to complete (${node_code}, id=${linode_id}, status=${status:-provisioning})"
  done

  payload="$(linode_json linodes view "$linode_id")"
  status="$(echo "$payload" | jq -r '.[0].status // .status // "unknown"')"
  ipv4="$(echo "$payload" | jq -r '(.[0].ipv4 // .ipv4 // [])[0] // ""')"
  printf '%s|%s' "$status" "$ipv4"
}

create_linode_for_node() {
  local code="$1" region="$2" fqdn="$3" node_role="$4"
  local label="upright-${code}-${ROOT_DOMAIN//./-}"
  local existing linode_id root_pass stackscript_data created wait_result status ipv4

  existing="$(jq -r --arg code "$code" '.nodes[] | select(.code==$code) | .linode_id // empty' "$STATE_PATH")"
  if [[ -n "$existing" ]]; then
    info "Node ${code} already has linode_id=${existing}; skipping create"
    return
  fi

  if $DRY_RUN; then
    info "DRY-RUN: would create node code=${code} region=${region} fqdn=${fqdn}"
    return
  fi

  root_pass="$(openssl rand -base64 24)"
  stackscript_data="$(jq -cn --arg DEPLOY_USER "$DEPLOY_USER" --arg DEPLOY_SSH_PUBKEY "$SSH_PUBKEY_VALUE" --arg SSH_PORT "$SSH_PORT" --arg NODE_ROLE "$node_role" --arg NODE_FQDN "$fqdn" --arg ENABLE_FAIL2BAN "yes" '{DEPLOY_USER:$DEPLOY_USER,DEPLOY_SSH_PUBKEY:$DEPLOY_SSH_PUBKEY,SSH_PORT:$SSH_PORT,NODE_ROLE:$NODE_ROLE,NODE_FQDN:$NODE_FQDN,ENABLE_FAIL2BAN:$ENABLE_FAIL2BAN}')"
  local interfaces_json
  interfaces_json='[{"public":{},"primary":true,"firewall_id":null}]'

  info "Creating Linode ${label} in ${region}"
  run_capture_with_spinner created "Submitting Linode create request (${code} in ${region})" \
    linode_cmd linodes create \
      --label "$label" --region "$region" --type "$INSTANCE_TYPE" --image "$IMAGE" \
      --root_pass "$root_pass" --stackscript_id "$STACKSCRIPT_ID" \
      --stackscript_data "$stackscript_data" \
      --interface_generation linode \
      --interfaces "$interfaces_json" --json

  linode_id="$(echo "$created" | jq -r '.[0].id // .id // empty')"
  [[ -n "$linode_id" ]] || die "Failed to parse Linode ID for ${code}"

  wait_result="$(wait_for_linode_running "$linode_id" "$code")"
  status="${wait_result%%|*}"
  ipv4="${wait_result#*|}"

  info "Node ${code}: id=${linode_id} status=${status} ipv4=${ipv4:-none}"
  update_node_state "$code" "$linode_id" "$ipv4" "$status"
}

provision_linode_nodes_classic() {
  create_linode_for_node "app" "$APP_REGION" "app.${UPRIGHT_SUFFIX}" "app"
  create_linode_for_node "ord" "$ORD_REGION" "ord.${UPRIGHT_SUFFIX}" "ord"
  create_linode_for_node "iad" "$IAD_REGION" "iad.${UPRIGHT_SUFFIX}" "iad"
  create_linode_for_node "sea" "$SEA_REGION" "sea.${UPRIGHT_SUFFIX}" "sea"
}

provision_linode_nodes() {
  info "Provisioning Linodes"
  set_phase "provisioning"
  provision_linode_nodes_classic

  if $DRY_RUN; then
    set_phase "planned"
  else
    set_phase "provisioned"
  fi
}

ensure_linode_dns_records() {
  local domain_json domain_id
  domain_json="$(linode_json domains list --domain "$ROOT_DOMAIN")"
  domain_id="$(echo "$domain_json" | jq -r '.[0].id // empty')"
  [[ -n "$domain_id" ]] || die "Could not find Linode DNS zone for ${ROOT_DOMAIN}"

  for code in app ord iad sea; do
    local fqdn record_name ip records record_id
    fqdn="$(fqdn_for_code "$code")"
    record_name="$(record_name_for_code "$code")"
    ip="$(node_ipv4 "$code")"
    [[ -n "$ip" ]] || die "Missing IP for node ${code}; cannot create DNS record"

    records="$(linode_json domains records-list "$domain_id" --type A --name "$record_name")"
    record_id="$(echo "$records" | jq -r '.[0].id // empty')"

    if [[ -n "$record_id" ]]; then
      info "Updating Linode DNS A ${fqdn} -> ${ip}"
      if ! $DRY_RUN; then
        linode_cmd domains records-update "$domain_id" "$record_id" --target "$ip" --ttl_sec 120 >/dev/null
      fi
    else
      info "Creating Linode DNS A ${fqdn} -> ${ip}"
      if ! $DRY_RUN; then
        linode_cmd domains records-create "$domain_id" --type A --name "$record_name" --target "$ip" --ttl_sec 120 >/dev/null
      fi
    fi
  done
}

prompt_cloudflare_token() {
  if [[ -n "$CLOUDFLARE_API_TOKEN" ]]; then
    return
  fi
  if $NON_INTERACTIVE; then
    die "--non-interactive with cloudflare-dns requires --cloudflare-token"
  fi
  read -r -s -p "Cloudflare API token (Zone DNS Edit + Zone Read): " CLOUDFLARE_API_TOKEN
  echo
  [[ -n "$CLOUDFLARE_API_TOKEN" ]] || die "Cloudflare API token is required"
}

resolve_cloudflare_zone_id() {
  local payload success
  payload="$(curl -fsS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones?name=${ROOT_DOMAIN}&status=active")"
  success="$(echo "$payload" | jq -r '.success')"
  [[ "$success" == "true" ]] || die "Cloudflare zone lookup failed for ${ROOT_DOMAIN}"
  CLOUDFLARE_ZONE_ID="$(echo "$payload" | jq -r '.result[0].id // empty')"
  [[ -n "$CLOUDFLARE_ZONE_ID" ]] || die "No active Cloudflare zone found for ${ROOT_DOMAIN}"
}

upsert_cloudflare_record() {
  local fqdn="$1" ip="$2" existing record_id
  existing="$(curl -fsS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=A&name=${fqdn}")"
  record_id="$(echo "$existing" | jq -r '.result[0].id // empty')"

  if [[ -n "$record_id" ]]; then
    info "Updating Cloudflare DNS A ${fqdn} -> ${ip}"
    if ! $DRY_RUN; then
      curl -fsS -X PUT -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${record_id}" --data "$(jq -cn --arg name "$fqdn" --arg content "$ip" '{type:"A",name:$name,content:$content,ttl:120,proxied:false}')" >/dev/null
    fi
  else
    info "Creating Cloudflare DNS A ${fqdn} -> ${ip}"
    if ! $DRY_RUN; then
      curl -fsS -X POST -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records" --data "$(jq -cn --arg name "$fqdn" --arg content "$ip" '{type:"A",name:$name,content:$content,ttl:120,proxied:false}')" >/dev/null
    fi
  fi
}

ensure_cloudflare_dns_records() {
  if $DRY_RUN; then
    info "DRY-RUN: would manage Cloudflare DNS records"
  else
    prompt_cloudflare_token
    resolve_cloudflare_zone_id
  fi

  for code in app ord iad sea; do
    local fqdn ip
    fqdn="$(fqdn_for_code "$code")"
    ip="$(node_ipv4 "$code")"
    [[ -n "$ip" ]] || die "Missing IP for node ${code}; cannot create DNS record"
    if $DRY_RUN; then
      info "DRY-RUN: Cloudflare A ${fqdn} -> ${ip}"
    else
      upsert_cloudflare_record "$fqdn" "$ip"
    fi
  done
}

show_manual_dns_instructions() {
  echo
  echo "Create these A records in your DNS provider:"
  for code in app ord iad sea; do
    echo "  - $(fqdn_for_code "$code")  A  $(node_ipv4 "$code")"
  done
  if $DRY_RUN; then
    info "DRY-RUN: manual DNS step skipped"
    return
  fi
  if $NON_INTERACTIVE; then
    if $MANUAL_DNS_CONFIRMED; then
      info "Manual DNS confirmation pre-approved via --manual-dns-confirmed"
      return
    fi
    die "--non-interactive manual DNS mode requires --manual-dns-confirmed"
  fi
  read -r -p "Press Enter after DNS records are created..." _
}

verify_dns_records() {
  if $DRY_RUN; then
    info "DRY-RUN: DNS verification skipped"
    return
  fi

  info "Verifying DNS propagation"
  for code in app ord iad sea; do
    local fqdn expected_ip resolved ok=false
    fqdn="$(fqdn_for_code "$code")"
    expected_ip="$(node_ipv4 "$code")"
    for _ in $(seq 1 30); do
      resolved="$(dig +short A "$fqdn" | tr '\n' ' ')"
      if echo "$resolved" | grep -qw "$expected_ip"; then ok=true; break; fi
      sleep 10
    done
    [[ "$ok" == true ]] || die "DNS verification failed for ${fqdn}. Expected ${expected_ip}."
    info "DNS OK: ${fqdn} -> ${expected_ip}"
  done
}

configure_dns() {
  info "Configuring DNS via mode=${DNS_MODE}"
  set_phase "dns_configuring"
  set_dns_status "in_progress"

  case "$DNS_MODE" in
    linode-dns) ensure_linode_dns_records ;;
    cloudflare-dns) ensure_cloudflare_dns_records ;;
    manual) show_manual_dns_instructions ;;
    *) die "Unsupported DNS mode: ${DNS_MODE}" ;;
  esac

  verify_dns_records
  set_dns_status "configured"
  set_phase "dns_configured"
}

write_config_deploy_yml() {
  local app ord iad sea app_fqdn ord_fqdn iad_fqdn sea_fqdn
  app="$(node_ipv4 app)"; ord="$(node_ipv4 ord)"; iad="$(node_ipv4 iad)"; sea="$(node_ipv4 sea)"
  app_fqdn="$(fqdn_for_code app)"; ord_fqdn="$(fqdn_for_code ord)"; iad_fqdn="$(fqdn_for_code iad)"; sea_fqdn="$(fqdn_for_code sea)"

  if ! $DRY_RUN; then
    [[ -n "$app" && -n "$ord" && -n "$iad" && -n "$sea" ]] || die "Missing node IP data for deploy.yml generation"
  fi

  cat > config/deploy.yml <<YAML
service: upright
image: ${IMAGE_NAME}

servers:
  web:
    hosts:
      - ${app_fqdn}: [admin]
      - ${ord}: [ord]
      - ${iad}: [iad]
      - ${sea}: [sea]
  jobs:
    hosts:
      - ${ord}: [ord]
      - ${iad}: [iad]
      - ${sea}: [sea]
    cmd: bin/jobs

ssh:
  user: ${DEPLOY_USER}
  port: ${SSH_PORT}

registry:
  server: ${REGISTRY_SERVER}
  username:
    - KAMAL_REGISTRY_USERNAME
  password:
    - KAMAL_REGISTRY_PASSWORD

builder:
  arch: amd64

proxy:
  app_port: 3000
  ssl: false
  forward_headers: true
  run:
    http_port: 8080
    https_port: 8443
  hosts:
    - ${app_fqdn}
    - ${ord_fqdn}
    - ${iad_fqdn}
    - ${sea_fqdn}

env:
  clear:
    UPRIGHT_HOSTNAME: ${UPRIGHT_SUFFIX}
    PLAYWRIGHT_SERVER_URL: ws://upright-playwright:53333/playwright
    PROMETHEUS_URL: http://upright-prometheus:9090
    ALERTMANAGER_URL: http://upright-alertmanager:9093
  secret:
    - RAILS_MASTER_KEY
    - ADMIN_PASSWORD
    - DAYLIGHTOPS_PROBE_EMAIL
    - DAYLIGHTOPS_PROBE_PASSWORD
  tags:
    admin:
      SITE_SUBDOMAIN: app
    ord:
      SITE_SUBDOMAIN: ord
    iad:
      SITE_SUBDOMAIN: iad
    sea:
      SITE_SUBDOMAIN: sea

volumes:
  - "upright_storage:/rails/storage"

accessories:
  playwright:
    image: jacoblincool/playwright:chromium-server-1.55.0
    port: "127.0.0.1:53333:53333"
    roles:
      - jobs

  prometheus:
    image: prom/prometheus:v3.2.1
    host: ${app_fqdn}
    cmd: >-
      --config.file=/etc/prometheus/prometheus.yml
      --storage.tsdb.path=/prometheus
      --storage.tsdb.retention.time=30d
      --web.enable-otlp-receiver
    files:
      - config/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - config/prometheus/rules/upright.rules.yml:/etc/prometheus/rules/upright.rules.yml
    volumes:
      - prometheus_data:/prometheus

  alertmanager:
    image: prom/alertmanager:v0.28.1
    host: ${app_fqdn}
    cmd: --config.file=/etc/alertmanager/alertmanager.yml
    files:
      - config/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml
    volumes:
      - alertmanager_data:/alertmanager

aliases:
  console: app exec -i "bin/rails console"
  logs: app logs -f

retain_containers: 3
YAML
}

write_config_sites_yml() {
  cat > config/sites.yml <<'YAML'
shared:
  sites:
    - code: ord
      city: Chicago
      country: US
      geohash: dp3wnp

    - code: iad
      city: Washington
      country: US
      geohash: dqcjqb

    - code: sea
      city: Seattle
      country: US
      geohash: c23nb6
YAML
}

write_kamal_secrets_template() {
  cat > .kamal/secrets <<EOF_SECRETS
# Secrets defined here are available for reference under registry/password, env/secret, builder/secrets,
# and accessories/*/env/secret in config/deploy.yml. All secrets should be pulled from either
# password manager, ENV, or a file. DO NOT ENTER RAW CREDENTIALS HERE! This file needs to be safe for git.

KAMAL_REGISTRY_USERNAME=${REGISTRY_USERNAME}
KAMAL_REGISTRY_PASSWORD=\$KAMAL_REGISTRY_PASSWORD
RAILS_MASTER_KEY=\$(cat config/master.key)
ADMIN_PASSWORD=\$ADMIN_PASSWORD
DAYLIGHTOPS_PROBE_EMAIL=\$DAYLIGHTOPS_PROBE_EMAIL
DAYLIGHTOPS_PROBE_PASSWORD=\$DAYLIGHTOPS_PROBE_PASSWORD
EOF_SECRETS
}

generate_config_files() {
  info "Generating config files"
  set_phase "config_generating"

  if $DRY_RUN; then
    info "DRY-RUN: would write config/deploy.yml"
    info "DRY-RUN: would write config/sites.yml"
    info "DRY-RUN: would write .kamal/secrets"
    set_phase "config_planned"
    return
  fi

  write_config_deploy_yml
  write_config_sites_yml
  write_kamal_secrets_template
  set_phase "config_generated"
  info "Wrote config/deploy.yml, config/sites.yml, .kamal/secrets"
}

run_kamal_deploy() {
  if $DRY_RUN; then
    info "DRY-RUN: would run eval \"\$(bin/load-secrets)\""
    info "DRY-RUN: would run bin/kamal setup"
    info "DRY-RUN: would run bin/kamal deploy"
    return
  fi

  if [[ "$RUN_DEPLOY" == "yes" ]]; then
    :
  elif [[ "$RUN_DEPLOY" == "no" ]] || $NON_INTERACTIVE; then
    warn "Skipped kamal deploy"
    return
  else
    read -r -p "Run kamal setup + deploy now? [y/N]: " yn
    if [[ ! "${yn}" =~ ^[Yy]$ ]]; then
      warn "Skipped kamal deploy by user choice"
      return
    fi
  fi

  set_phase "deploying"
  eval "$(bin/load-secrets)"
  bin/kamal setup
  bin/kamal deploy
  set_phase "deployed"
}

post_deploy_checks() {
  if $DRY_RUN; then
    info "DRY-RUN: would run post-deploy endpoint checks"
    return
  fi

  info "Running basic endpoint checks"
  local failures=0
  for code in app ord iad sea; do
    local fqdn
    fqdn="$(fqdn_for_code "$code")"
    if curl -fsS --max-time 20 "https://${fqdn}" >/dev/null; then
      info "HTTP OK: https://${fqdn}"
    else
      warn "HTTP check failed: https://${fqdn}"
      failures=$((failures + 1))
    fi
  done

  if [[ "$failures" -gt 0 ]]; then
    warn "Post-deploy checks completed with ${failures} failure(s)"
  else
    info "Post-deploy checks passed"
  fi
}

confirm_destroy() {
  if $DRY_RUN; then
    info "DRY-RUN: destroy confirmation skipped"
    return
  fi
  if $CONFIRM_DESTROY_FLAG; then
    info "Destroy confirmed via --confirm-destroy"
    return
  fi
  if $NON_INTERACTIVE; then
    die "--non-interactive destroy requires --confirm-destroy"
  fi
  echo
  echo "This will delete Linodes and DNS records tracked in ${STATE_PATH}."
  read -r -p "Type DESTROY to continue: " confirm
  [[ "$confirm" == "DESTROY" ]] || die "Destroy cancelled"
}

delete_linode_dns_records() {
  local domain_json domain_id
  domain_json="$(linode_json domains list --domain "$ROOT_DOMAIN")"
  domain_id="$(echo "$domain_json" | jq -r '.[0].id // empty')"
  [[ -n "$domain_id" ]] || { warn "No Linode DNS zone found for ${ROOT_DOMAIN}; skipping"; return; }

  for code in app ord iad sea; do
    local record_name expected_ip records
    record_name="$(record_name_for_code "$code")"
    expected_ip="$(node_ipv4 "$code")"
    records="$(linode_json domains records-list "$domain_id" --type A --name "$record_name")"
    echo "$records" | jq -c '.[]?' | while read -r row; do
      local rid target
      rid="$(echo "$row" | jq -r '.id')"
      target="$(echo "$row" | jq -r '.target // ""')"
      if [[ -n "$expected_ip" && "$target" != "$expected_ip" ]]; then
        warn "Skip Linode DNS record id=${rid} name=${record_name} target=${target} (expected ${expected_ip})"
        continue
      fi
      if $DRY_RUN; then
        info "DRY-RUN: would delete Linode DNS record id=${rid} name=${record_name}"
      else
        info "Deleting Linode DNS record id=${rid} name=${record_name}"
        linode_cmd domains records-delete "$domain_id" "$rid" >/dev/null
      fi
    done
  done
}

delete_cloudflare_dns_records() {
  if ! $DRY_RUN; then
    prompt_cloudflare_token
    resolve_cloudflare_zone_id
  fi

  for code in app ord iad sea; do
    local fqdn expected_ip listing
    fqdn="$(fqdn_for_code "$code")"
    expected_ip="$(node_ipv4 "$code")"
    if $DRY_RUN; then
      info "DRY-RUN: would delete Cloudflare A ${fqdn} (target ${expected_ip})"
      continue
    fi

    listing="$(curl -fsS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=A&name=${fqdn}")"
    echo "$listing" | jq -c '.result[]?' | while read -r row; do
      local rid target
      rid="$(echo "$row" | jq -r '.id')"
      target="$(echo "$row" | jq -r '.content // ""')"
      if [[ -n "$expected_ip" && "$target" != "$expected_ip" ]]; then
        warn "Skip Cloudflare record id=${rid} name=${fqdn} target=${target} (expected ${expected_ip})"
        continue
      fi
      info "Deleting Cloudflare DNS record id=${rid} name=${fqdn}"
      curl -fsS -X DELETE -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${rid}" >/dev/null
    done
  done
}

delete_dns_records_for_mode() {
  case "$DNS_MODE" in
    linode-dns) delete_linode_dns_records ;;
    cloudflare-dns) delete_cloudflare_dns_records ;;
    manual) info "Manual DNS mode; skipping DNS record deletion" ;;
    *) warn "Unknown DNS mode ${DNS_MODE}; skipping DNS deletion" ;;
  esac
}

delete_linodes_from_state() {
  for code in app ord iad sea; do
    local id
    id="$(node_linode_id "$code")"
    if [[ -z "$id" || "$id" == "null" ]]; then
      info "No Linode id for ${code}; skipping"
      continue
    fi
    if $DRY_RUN; then
      info "DRY-RUN: would delete Linode id=${id} (${code})"
    else
      info "Deleting Linode id=${id} (${code})"
      linode_cmd linodes delete "$id" >/dev/null || warn "Failed deleting Linode id=${id}"
    fi
  done
}

maybe_delete_stackscript() {
  local choice
  if [[ -z "$STACKSCRIPT_ID" || "$STACKSCRIPT_ID" == "null" ]]; then
    return
  fi

  if $DRY_RUN; then
    info "DRY-RUN: would optionally delete StackScript id=${STACKSCRIPT_ID}"
    return
  fi

  if $DELETE_STACKSCRIPT; then
    linode_cmd stackscripts delete "$STACKSCRIPT_ID" >/dev/null || warn "Failed deleting StackScript id=${STACKSCRIPT_ID}"
    return
  fi
  if $NON_INTERACTIVE; then
    info "Skipping StackScript deletion (set --delete-stackscript to enable)"
    return
  fi

  read -r -p "Delete private StackScript id=${STACKSCRIPT_ID} too? [y/N]: " choice
  if [[ "${choice}" =~ ^[Yy]$ ]]; then
    linode_cmd stackscripts delete "$STACKSCRIPT_ID" >/dev/null || warn "Failed deleting StackScript id=${STACKSCRIPT_ID}"
  fi
}

archive_state_file() {
  local archived="infra/state.destroyed.$(date -u +%Y%m%dT%H%M%SZ).json"
  if $DRY_RUN; then
    info "DRY-RUN: would archive ${STATE_PATH} to ${archived}"
  else
    mv "$STATE_PATH" "$archived"
    info "Archived state to ${archived}"
  fi
}

show_next_steps() {
  cat <<'NEXT'

Setup flow complete:
- StackScript synced
- Linodes provisioned
- DNS configured and verified
- Config files generated

If deploy was skipped, run:
  eval "$(bin/load-secrets)"
  bin/kamal setup
  bin/kamal deploy
NEXT
}

emit_agent_output() {
  local status="${1:-unknown}" message="${2:-}"
  [[ -n "$OUTPUT_JSON" ]] || return 0

  mkdir -p "$(dirname "$OUTPUT_JSON")"
  local now phase
  now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  phase=""
  if [[ -f "$STATE_PATH" ]]; then
    phase="$(jq -r '.phase // empty' "$STATE_PATH" 2>/dev/null || true)"
    jq -n \
      --arg generated_at "$now" \
      --arg status "$status" \
      --arg message "$message" \
      --arg phase "$phase" \
      --arg root_domain "$ROOT_DOMAIN" \
      --arg upright_suffix "$UPRIGHT_SUFFIX" \
      --arg dns_mode "$DNS_MODE" \
      --arg instance_type "$INSTANCE_TYPE" \
      --arg provision_mode "$PROVISION_MODE" \
      --arg image "$IMAGE" \
      --arg deploy_user "$DEPLOY_USER" \
      --arg ssh_port "$SSH_PORT" \
      --arg ssh_pubkey_path "$SSH_PUBKEY_PATH" \
      --arg app_region "$APP_REGION" \
      --arg ord_region "$ORD_REGION" \
      --arg iad_region "$IAD_REGION" \
      --arg sea_region "$SEA_REGION" \
      --arg stackscript_id "$STACKSCRIPT_ID" \
      --arg dry_run "$DRY_RUN" \
      --arg resume "$RESUME" \
      --arg destroy "$DESTROY" \
      --arg non_interactive "$NON_INTERACTIVE" \
      --arg auto_approve "$AUTO_APPROVE" \
      --arg state_path "$STATE_PATH" \
      --slurpfile state "$STATE_PATH" \
      '{
        generated_at: $generated_at,
        status: $status,
        message: $message,
        phase: $phase,
        mode: {
          dry_run: ($dry_run == "true"),
          resume: ($resume == "true"),
          destroy: ($destroy == "true"),
          non_interactive: ($non_interactive == "true"),
          auto_approve: ($auto_approve == "true")
        },
        config: {
          root_domain: $root_domain,
          upright_suffix: $upright_suffix,
          dns_mode: $dns_mode,
          instance_type: $instance_type,
          provision_mode: $provision_mode,
          image: $image,
          deploy_user: $deploy_user,
          ssh_port: $ssh_port,
          ssh_pubkey_path: $ssh_pubkey_path,
          app_region: $app_region,
          ord_region: $ord_region,
          iad_region: $iad_region,
          sea_region: $sea_region,
          stackscript_id: $stackscript_id
        },
        state_path: $state_path,
        state: ($state[0] // null)
      }' > "$OUTPUT_JSON" || warn "Failed writing output JSON: ${OUTPUT_JSON}"
    return 0
  fi

  jq -n \
    --arg generated_at "$now" \
    --arg status "$status" \
    --arg message "$message" \
    --arg phase "$phase" \
    --arg root_domain "$ROOT_DOMAIN" \
    --arg upright_suffix "$UPRIGHT_SUFFIX" \
    --arg dns_mode "$DNS_MODE" \
    --arg instance_type "$INSTANCE_TYPE" \
    --arg provision_mode "$PROVISION_MODE" \
    --arg image "$IMAGE" \
    --arg deploy_user "$DEPLOY_USER" \
    --arg ssh_port "$SSH_PORT" \
    --arg ssh_pubkey_path "$SSH_PUBKEY_PATH" \
    --arg app_region "$APP_REGION" \
    --arg ord_region "$ORD_REGION" \
    --arg iad_region "$IAD_REGION" \
    --arg sea_region "$SEA_REGION" \
    --arg stackscript_id "$STACKSCRIPT_ID" \
    --arg dry_run "$DRY_RUN" \
    --arg resume "$RESUME" \
    --arg destroy "$DESTROY" \
    --arg non_interactive "$NON_INTERACTIVE" \
    --arg auto_approve "$AUTO_APPROVE" \
    --arg state_path "$STATE_PATH" \
    '{
      generated_at: $generated_at,
      status: $status,
      message: $message,
      phase: $phase,
      mode: {
        dry_run: ($dry_run == "true"),
        resume: ($resume == "true"),
        destroy: ($destroy == "true"),
        non_interactive: ($non_interactive == "true"),
        auto_approve: ($auto_approve == "true")
      },
      config: {
        root_domain: $root_domain,
        upright_suffix: $upright_suffix,
        dns_mode: $dns_mode,
        instance_type: $instance_type,
        provision_mode: $provision_mode,
        image: $image,
        deploy_user: $deploy_user,
        ssh_port: $ssh_port,
        ssh_pubkey_path: $ssh_pubkey_path,
        app_region: $app_region,
        ord_region: $ord_region,
        iad_region: $iad_region,
        sea_region: $sea_region,
        stackscript_id: $stackscript_id
      },
      state_path: $state_path,
      state: null
    }' > "$OUTPUT_JSON" || warn "Failed writing output JSON: ${OUTPUT_JSON}"
}

resume_mode() {
  load_state_context

  ensure_linode_auth

  case "$CURRENT_PHASE" in
    planning|planned|provisioning)
      load_ssh_pubkey
      ensure_stackscript
      save_stackscript_state
      provision_linode_nodes
      configure_dns
      generate_config_files
      run_kamal_deploy
      post_deploy_checks
      ;;
    provisioned|dns_configuring)
      configure_dns
      generate_config_files
      run_kamal_deploy
      post_deploy_checks
      ;;
    dns_configured|config_generating|config_generated)
      generate_config_files
      run_kamal_deploy
      post_deploy_checks
      ;;
    deploying|deployed)
      post_deploy_checks
      ;;
    *)
      warn "Unrecognized phase '${CURRENT_PHASE}'. Showing state only."
      jq . "$STATE_PATH"
      ;;
  esac

  info "Resume complete"
}

destroy_mode() {
  load_state_context
  ensure_linode_auth
  confirm_destroy

  delete_dns_records_for_mode
  delete_linodes_from_state
  maybe_delete_stackscript
  archive_state_file

  info "Destroy flow complete"
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) DRY_RUN=true ;;
      --resume) RESUME=true ;;
      --destroy) DESTROY=true ;;
      --non-interactive) NON_INTERACTIVE=true ;;
      --yes) AUTO_APPROVE=true ;;
      --run-deploy) RUN_DEPLOY="yes" ;;
      --skip-deploy) RUN_DEPLOY="no" ;;
      --manual-dns-confirmed) MANUAL_DNS_CONFIRMED=true ;;
      --confirm-destroy) CONFIRM_DESTROY_FLAG=true ;;
      --delete-stackscript) DELETE_STACKSCRIPT=true ;;
      --linode-pat=*) LINODE_PAT="${1#*=}" ;;
      --linode-pat) shift; LINODE_PAT="${1:-}"; [[ -n "$LINODE_PAT" ]] || die "--linode-pat requires a value" ;;
      --root-domain=*) ROOT_DOMAIN="${1#*=}" ;;
      --root-domain) shift; ROOT_DOMAIN="${1:-}"; [[ -n "$ROOT_DOMAIN" ]] || die "--root-domain requires a value" ;;
      --upright-suffix=*) UPRIGHT_SUFFIX="${1#*=}" ;;
      --upright-suffix) shift; UPRIGHT_SUFFIX="${1:-}" ;;
      --plan-mode=*) PLAN_MODE="${1#*=}" ;;
      --plan-mode) shift; PLAN_MODE="${1:-}"; [[ -n "$PLAN_MODE" ]] || die "--plan-mode requires a value" ;;
      --instance-type=*) INSTANCE_TYPE="${1#*=}" ;;
      --instance-type) shift; INSTANCE_TYPE="${1:-}"; [[ -n "$INSTANCE_TYPE" ]] || die "--instance-type requires a value" ;;
      --provision-mode=*) PROVISION_MODE="${1#*=}" ;;
      --provision-mode) shift; PROVISION_MODE="${1:-}"; [[ -n "$PROVISION_MODE" ]] || die "--provision-mode requires a value" ;;
      --image=*) IMAGE="${1#*=}" ;;
      --image) shift; IMAGE="${1:-}"; [[ -n "$IMAGE" ]] || die "--image requires a value" ;;
      --deploy-user=*) DEPLOY_USER="${1#*=}" ;;
      --deploy-user) shift; DEPLOY_USER="${1:-}"; [[ -n "$DEPLOY_USER" ]] || die "--deploy-user requires a value" ;;
      --ssh-port=*) SSH_PORT="${1#*=}" ;;
      --ssh-port) shift; SSH_PORT="${1:-}"; [[ -n "$SSH_PORT" ]] || die "--ssh-port requires a value" ;;
      --registry-server=*) REGISTRY_SERVER="${1#*=}" ;;
      --registry-server) shift; REGISTRY_SERVER="${1:-}"; [[ -n "$REGISTRY_SERVER" ]] || die "--registry-server requires a value" ;;
      --registry-username=*) REGISTRY_USERNAME="${1#*=}" ;;
      --registry-username) shift; REGISTRY_USERNAME="${1:-}"; [[ -n "$REGISTRY_USERNAME" ]] || die "--registry-username requires a value" ;;
      --image-name=*) IMAGE_NAME="${1#*=}" ;;
      --image-name) shift; IMAGE_NAME="${1:-}"; [[ -n "$IMAGE_NAME" ]] || die "--image-name requires a value" ;;
      --dns-mode=*) DNS_MODE="${1#*=}" ;;
      --dns-mode) shift; DNS_MODE="${1:-}"; [[ -n "$DNS_MODE" ]] || die "--dns-mode requires a value" ;;
      --region-mode=*) REGION_MODE="${1#*=}" ;;
      --region-mode) shift; REGION_MODE="${1:-}"; [[ -n "$REGION_MODE" ]] || die "--region-mode requires a value" ;;
      --app-region=*) APP_REGION="${1#*=}" ;;
      --app-region) shift; APP_REGION="${1:-}"; [[ -n "$APP_REGION" ]] || die "--app-region requires a value" ;;
      --ord-region=*) ORD_REGION="${1#*=}" ;;
      --ord-region) shift; ORD_REGION="${1:-}"; [[ -n "$ORD_REGION" ]] || die "--ord-region requires a value" ;;
      --iad-region=*) IAD_REGION="${1#*=}" ;;
      --iad-region) shift; IAD_REGION="${1:-}"; [[ -n "$IAD_REGION" ]] || die "--iad-region requires a value" ;;
      --sea-region=*) SEA_REGION="${1#*=}" ;;
      --sea-region) shift; SEA_REGION="${1:-}"; [[ -n "$SEA_REGION" ]] || die "--sea-region requires a value" ;;
      --ssh-key-source=*) SSH_KEY_SOURCE="${1#*=}" ;;
      --ssh-key-source) shift; SSH_KEY_SOURCE="${1:-}"; [[ -n "$SSH_KEY_SOURCE" ]] || die "--ssh-key-source requires a value" ;;
      --ssh-key-ids=*) SSH_KEY_IDS="${1#*=}" ;;
      --ssh-key-ids) shift; SSH_KEY_IDS="${1:-}"; [[ -n "$SSH_KEY_IDS" ]] || die "--ssh-key-ids requires a value" ;;
      --ssh-pubkey-path=*) SSH_PUBKEY_PATH="${1#*=}" ;;
      --ssh-pubkey-path) shift; SSH_PUBKEY_PATH="${1:-}"; [[ -n "$SSH_PUBKEY_PATH" ]] || die "--ssh-pubkey-path requires a value" ;;
      --cloudflare-token=*) CLOUDFLARE_API_TOKEN="${1#*=}" ;;
      --cloudflare-token) shift; CLOUDFLARE_API_TOKEN="${1:-}"; [[ -n "$CLOUDFLARE_API_TOKEN" ]] || die "--cloudflare-token requires a value" ;;
      --output-json=*) OUTPUT_JSON="${1#*=}" ;;
      --output-json) shift; OUTPUT_JSON="${1:-}"; [[ -n "$OUTPUT_JSON" ]] || die "--output-json requires a value" ;;
      --stackscript-label=*) STACKSCRIPT_LABEL="${1#*=}" ;;
      --stackscript-label) shift; STACKSCRIPT_LABEL="${1:-}"; [[ -n "$STACKSCRIPT_LABEL" ]] || die "--stackscript-label requires a value" ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown arg: $1" ;;
    esac
    shift
  done

  local count=0
  $RESUME && count=$((count + 1))
  $DESTROY && count=$((count + 1))
  [[ $count -le 1 ]] || die "Use only one of --resume or --destroy"

  PLAN_MODE="$(echo "$PLAN_MODE" | tr '[:upper:]' '[:lower:]')"
  REGION_MODE="$(echo "$REGION_MODE" | tr '[:upper:]' '[:lower:]')"
  DNS_MODE="$(echo "$DNS_MODE" | tr '[:upper:]' '[:lower:]')"
  SSH_KEY_SOURCE="$(echo "$SSH_KEY_SOURCE" | tr '[:upper:]' '[:lower:]')"
  RUN_DEPLOY="$(echo "$RUN_DEPLOY" | tr '[:upper:]' '[:lower:]')"

  case "$PROVISION_MODE" in
    classic) ;;
    tui)
      warn "--provision-mode tui is deprecated; using classic"
      PROVISION_MODE="classic"
      ;;
    *) die "Invalid --provision-mode: ${PROVISION_MODE} (expected classic)" ;;
  esac
  [[ "$SSH_PORT" =~ ^[0-9]+$ ]] || die "Invalid --ssh-port: ${SSH_PORT}"
}

main() {
  parse_args "$@"
  banner
  preflight

  if $RESUME; then
    resume_mode
    emit_agent_output "ok" "Resume flow complete"
    exit 0
  fi

  if $DESTROY; then
    destroy_mode
    emit_agent_output "ok" "Destroy flow complete"
    exit 0
  fi

  ensure_linode_auth
  load_ssh_pubkey
  prompt_inputs
  confirm_plan

  init_state
  ensure_stackscript
  save_stackscript_state
  provision_linode_nodes
  configure_dns
  generate_config_files
  run_kamal_deploy
  post_deploy_checks
  show_next_steps

  info "Wrote ${STATE_PATH}"
  emit_agent_output "ok" "Setup flow complete"
}

main "$@"
